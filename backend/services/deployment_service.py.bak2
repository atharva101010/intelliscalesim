import subprocess
import time
import json
import tempfile
import shutil
import os
from typing import Dict, Optional
from datetime import datetime
from urllib.parse import urlparse

class DeploymentService:
    def __init__(self):
        self.deployment_history = []
        
    def find_available_port(self, start_port=8001, end_port=9000):
        """Find an available port in the specified range"""
        for port in range(start_port, end_port):
            try:
                result = subprocess.run(
                    ['docker', 'ps', '--format', '{{.Ports}}'],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if f':{port}->' not in result.stdout:
                    return port
            except Exception as e:
                print(f"Error checking port {port}: {e}")
        return None
        
    def deploy_docker_image(self, image_name: str, container_name: str, 
                           port: Optional[int] = None, user_id: str = "student",
                           user_name: str = "Student", env_vars: dict = None,
                           credentials: Optional[Dict[str, str]] = None) -> Dict:
        """Deploy a Docker image from Docker Hub (supports private images with credentials)"""
        logged_in = False
        try:
            # Find available port if not specified
            if not port:
                port = self.find_available_port()
                if not port:
                    return {'success': False, 'message': 'No available ports'}
            
            # Check if container name already exists
            check_cmd = ['docker', 'ps', '-a', '--filter', f'name={container_name}', '--format', '{{.Names}}']
            result = subprocess.run(check_cmd, capture_output=True, text=True, timeout=5)
            if container_name in result.stdout:
                return {'success': False, 'message': f'Container name "{container_name}" already exists'}
            
            # Optional one-time docker login for private images
            if credentials and credentials.get('username') and credentials.get('password'):
                try:
                    print(f"ðŸ” Logging into Docker Hub for private image access...")
                    login_cmd = ['docker', 'login', '--username', credentials['username'], '--password-stdin']
                    proc = subprocess.Popen(
                        login_cmd, 
                        stdin=subprocess.PIPE, 
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.PIPE, 
                        text=True
                    )
                    stdout, stderr = proc.communicate(input=credentials['password'], timeout=30)
                    
                    if proc.returncode != 0:
                        return {
                            'success': False, 
                            'message': f'Docker login failed: {stderr or stdout}'
                        }
                    logged_in = True
                    print(f"âœ… Docker login successful")
                except Exception as e:
                    return {
                        'success': False, 
                        'message': f'Docker login error: {str(e)}'
                    }
            
            # Pull the image
            print(f"ðŸ“¥ Pulling image: {image_name}")
            pull_cmd = ['docker', 'pull', image_name]
            pull_result = subprocess.run(pull_cmd, capture_output=True, text=True, timeout=300)
            
            if pull_result.returncode != 0:
                # Logout if we logged in
                if logged_in:
                    try:
                        subprocess.run(['docker', 'logout'], capture_output=True, text=True, timeout=15)
                    except Exception:
                        pass
                
                return {
                    'success': False,
                    'message': f'Failed to pull image: {pull_result.stderr}'
                }
            
            # Prepare docker run command
            run_cmd = [
                'docker', 'run', '-d',
                '--name', container_name,
                '--label', 'deployed_by=student',
                '--label', f'user_id={user_id}',
                '--label', f'user_name={user_name}',
                '--label', f'deployed_at={datetime.now().isoformat()}',
                '--label', 'deployment_method=ui',
                '--restart', 'unless-stopped',
                '-p', f'{port}:80',
            ]
            
            # Add environment variables if provided
            if env_vars:
                for key, value in env_vars.items():
                    run_cmd.extend(['-e', f'{key}={value}'])
            
            run_cmd.append(image_name)
            
            # Run the container
            print(f"ðŸš€ Starting container: {container_name}")
            run_result = subprocess.run(run_cmd, capture_output=True, text=True, timeout=30)
            
            # Logout immediately after deployment
            if logged_in:
                try:
                    print(f"ðŸ”’ Logging out of Docker Hub...")
                    subprocess.run(['docker', 'logout'], capture_output=True, text=True, timeout=15)
                    print(f"âœ… Docker logout successful")
                except Exception as e:
                    print(f"âš ï¸  Docker logout warning: {e}")
            
            if run_result.returncode != 0:
                return {
                    'success': False,
                    'message': f'Failed to start container: {run_result.stderr}'
                }
            
            container_id = run_result.stdout.strip()
            
            # Add to deployment history
            deployment = {
                'id': int(time.time() * 1000),
                'containerId': container_id[:12],
                'containerName': container_name,
                'image': image_name,
                'port': port,
                'userId': user_id,
                'userName': user_name,
                'status': 'running',
                'timestamp': datetime.now().isoformat(),
                'method': 'docker_hub'
            }
            self.deployment_history.insert(0, deployment)
            
            return {
                'success': True,
                'message': 'Container deployed successfully',
                'data': {
                    'containerId': container_id[:12],
                    'containerName': container_name,
                    'image': image_name,
                    'port': port,
                    'url': f'http://localhost:{port}'
                }
            }
            
        except subprocess.TimeoutExpired:
            # Logout on timeout
            if logged_in:
                try:
                    subprocess.run(['docker', 'logout'], capture_output=True, text=True, timeout=15)
                except Exception:
                    pass
            return {'success': False, 'message': 'Deployment timed out'}
        except Exception as e:
            # Logout on error
            if logged_in:
                try:
                    subprocess.run(['docker', 'logout'], capture_output=True, text=True, timeout=15)
                except Exception:
                    pass
            return {'success': False, 'message': f'Deployment failed: {str(e)}'}
    
    def deploy_from_github(self, repo_url: str, container_name: str,
                          port: Optional[int] = None, user_id: str = "student",
                          user_name: str = "Student", dockerfile_path: str = "Dockerfile",
                          credentials: Optional[Dict[str, str]] = None) -> Dict:
        """Deploy from GitHub repository (supports private repos with credentials)"""
        tmpdir = None
        try:
            # Find available port if not specified
            if not port:
                port = self.find_available_port()
                if not port:
                    return {'success': False, 'message': 'No available ports'}
            
            # Check if container name already exists
            check_cmd = ['docker', 'ps', '-a', '--filter', f'name={container_name}', '--format', '{{.Names}}']
            result = subprocess.run(check_cmd, capture_output=True, text=True, timeout=5)
            if container_name in result.stdout:
                return {'success': False, 'message': f'Container name "{container_name}" already exists'}
            
            # Generate image name
            image_name = f'student-app-{container_name}:latest'
            
            print(f"ðŸ”¨ Building image from GitHub: {repo_url}")
            
            # Create temporary directory for cloning
            tmpdir = tempfile.mkdtemp(prefix='intelliscale_deploy_')
            print(f"ðŸ“ Created temp directory: {tmpdir}")
            
            # Prepare git clone command (with credentials if provided)
            if credentials and credentials.get('username') and credentials.get('token'):
                # Inject credentials into clone URL safely
                print(f"ðŸ” Cloning private repository with credentials...")
                parsed = urlparse(repo_url)
                auth_url = f"{parsed.scheme}://{credentials['username']}:{credentials['token']}@{parsed.netloc}{parsed.path}"
                clone_cmd = ['git', 'clone', '--depth', '1', auth_url, tmpdir]
            else:
                print(f"ðŸ“¦ Cloning public repository...")
                clone_cmd = ['git', 'clone', '--depth', '1', repo_url, tmpdir]
            
            # Clone repository
            clone_result = subprocess.run(
                clone_cmd, 
                capture_output=True, 
                text=True, 
                timeout=300
            )
            
            if clone_result.returncode != 0:
                if tmpdir:
                    shutil.rmtree(tmpdir, ignore_errors=True)
                return {
                    'success': False,
                    'message': f'Git clone failed: {clone_result.stderr or clone_result.stdout}'
                }
            
            print(f"âœ… Repository cloned successfully")
            
            # Build from local directory
            dockerfile_full_path = os.path.join(tmpdir, dockerfile_path)
            
            if not os.path.exists(dockerfile_full_path):
                shutil.rmtree(tmpdir, ignore_errors=True)
                return {
                    'success': False,
                    'message': f'Dockerfile not found at: {dockerfile_path}'
                }
            
            print(f"ðŸ—ï¸  Building Docker image...")
            build_cmd = [
                'docker', 'build',
                '-t', image_name,
                '-f', dockerfile_full_path,
                tmpdir
            ]
            
            build_result = subprocess.run(
                build_cmd, 
                capture_output=True, 
                text=True, 
                timeout=1200
            )
            
            # Cleanup temp directory immediately after build
            print(f"ðŸ§¹ Cleaning up temporary files...")
            try:
                shutil.rmtree(tmpdir, ignore_errors=True)
                tmpdir = None
            except Exception as e:
                print(f"âš ï¸  Cleanup warning: {e}")
            
            if build_result.returncode != 0:
                return {
                    'success': False,
                    'message': f'Failed to build image: {build_result.stderr}'
                }
            
            print(f"âœ… Image built successfully: {image_name}")
            
            # Deploy the built image (without credentials since it's now local)
            return self.deploy_docker_image(
                image_name=image_name,
                container_name=container_name,
                port=port,
                user_id=user_id,
                user_name=user_name
            )
            
        except subprocess.TimeoutExpired:
            if tmpdir:
                shutil.rmtree(tmpdir, ignore_errors=True)
            return {'success': False, 'message': 'Build timed out'}
        except Exception as e:
            if tmpdir:
                shutil.rmtree(tmpdir, ignore_errors=True)
            return {'success': False, 'message': f'Deployment failed: {str(e)}'}
    
    def stop_container(self, container_id: str) -> Dict:
        """Stop a running container"""
        try:
            result = subprocess.run(
                ['docker', 'stop', container_id],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                return {
                    'success': True,
                    'message': 'Container stopped successfully'
                }
            else:
                return {
                    'success': False,
                    'message': f'Failed to stop container: {result.stderr}'
                }
        except Exception as e:
            return {'success': False, 'message': f'Error stopping container: {str(e)}'}
    
    def remove_container(self, container_id: str, force: bool = False) -> Dict:
        """Remove a container"""
        try:
            cmd = ['docker', 'rm']
            if force:
                cmd.append('-f')
            cmd.append(container_id)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                return {
                    'success': True,
                    'message': 'Container removed successfully'
                }
            else:
                return {
                    'success': False,
                    'message': f'Failed to remove container: {result.stderr}'
                }
        except Exception as e:
            return {'success': False, 'message': f'Error removing container: {str(e)}'}
    
    def get_deployment_history(self, limit: int = 50) -> Dict:
        """Get deployment history"""
        try:
            return {
                'success': True,
                'data': self.deployment_history[:limit]
            }
        except Exception as e:
            return {'success': False, 'message': f'Error fetching history: {str(e)}'}
    
    def get_available_port(self) -> Dict:
        """Get next available port"""
        try:
            port = self.find_available_port()
            if port:
                return {
                    'success': True,
                    'data': {'port': port}
                }
            else:
                return {
                    'success': False,
                    'message': 'No available ports found'
                }
        except Exception as e:
            return {'success': False, 'message': f'Error finding port: {str(e)}'}

# Create singleton instance
deployment_service = DeploymentService()
